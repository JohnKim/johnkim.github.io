{"componentChunkName":"component---src-templates-post-template-tsx-content-file-path-users-gshs-documents-git-hub-johnkim-github-io-contents-posts-토근-기반-인증-json-web-token-mdx","path":"/authentication-jwt","result":{"data":{"mdx":{"slug":"/authentication-jwt","title":"토근 기반 인증 - JWT(JSON Web Token)","date":"2022-10-05","tags":[{"name":"authentication","slug":"authentication"},{"name":"JWT","slug":"JWT"}],"description":"서버는 확장성을 고려하여 반드시 Stateless 해야만 한다. 이러한 Stateless 서버 환경에 적합한 JWT 인증에 대한 Sequence Diagram 을 그려보았다.","body":"\nJWT 에 대해 간략하게 공유해야 할 일이 생겼다. 그래서 주요한 흐름을 아래와 같이 Sequence Diagram 으로 작성해 보았다.\n\nSequece Diagram 은 [mermaid](https://github.com/mermaid-js/mermaid) 로 작성하였고,\nMDX 에 보여질 수 있도록 Getsby에 [gatsby-remark-mermaid](https://www.gatsbyjs.com/plugins/gatsby-remark-mermaid/)플러그인을 추가하여 MDX 안에 다이어그램을 표시할 수 있도록 하였다.\n\nmermaid 는 코드를 작성해서 다양한 다이어그램을 그릴 수 있는 도구이다. Sequence Diagram 이외에도, flow chart, class diagram, ERD 등 다양한 다이어그램을 그릴 수 있다.\n\n## JWT 인증 절차\n\nJWT(JSON Web Token)는, JSON 형식의 데이터가 저장된 문자열 즉 토큰이다.\n\n사용자가 로그인 하는 과정을 통해, 인증서버는 사용자 인증 정보가 검증이 되면 이 토큰을 생성하고 발행하게 된다.\n\n### 사용자 로그인\n\n먼저, 로그인 과정부터 토큰 발행까지의 과정을 Sequence Diagram 으로 확인해보자.\n\n```mermaid\n\nsequenceDiagram\n\n    participant Client as Web Browser\n    participant Server as Authentication Server\n    participant Database as User Database\n\n\n    Client ->>+ Server: 사용자 로그인\n    Note right of Client: Basic Auth 해더에 아이디와 암호를 BASE64 인코딩 하여 요청\n    Server ->>+ Database: DB에 사용자 검증\n    Database -->>- Server: <br/>\n\n    Server ->> Server: Access Token, Refresh Token 발급\n\n    Server ->>+ Database: Refresh Token 저장\n    Database -->>- Server: <br/>\n\n    Server -->>- Client: Access Token, Refresh Token\n    Note left of  Server: Token 의 만료기간과 인가정보를 포함하여 응답. <br> 만료기간은 Access Token 은 짧게(1시간 미만) 하고 <br/> Refresh Token 은 길게(1주 미만) 으로 함\n\n```\n\n1. 사용자 로그인 요청을 한다.\n\n   보통 사용자의 username 과 password를 BASE64 인코딩하고 Request Header 에 담아 인증 서버에 로그인 요청을 하는 단계 이다.\n\n2. 인증 서버는 BASE64로 인코딩한 username 과 password 를 디코딩하여 사용자 DB 의 사용자 정보와 동일한지 검증한다.\n\n3. 인증 서버는 access token 과 refresh token 을 생성하고, refresh token 은 사용자 DB 에 저장한다.\n\n   refresh token 을 DB 에 저장하는 이유는, 나중에 access token 이 만료 되었을 때 refresh token 을 검증하고 새로은 access token 을 발행하기 위함이다.\n\n4. 이제 발급된 access token 과 refresh token 을 Client 에 응답으로 전달한다.\n\n#### JWT 구조\n\n인증서버는 사용자 로그인 검증이 되면, access token 과 refresh token 두가지의 JWT 를 생성하게 되며, 두개의 token 모두 아래와 같은 구조로 같게 된다.\n\n```\nHeader.Payload.Signature\n```\n\n- Header : 토큰 종류와 해시 알고리즘 정보\n\n  ```\n  {\n  \t\"alg\": \"HS256\",\n  \t\"typ\": \"JWT\"\n  }\n  ```\n\n- Payload : 토큰의 내용물이 인코딩된 부분\n\n- Signature : 시그니처를 통해 토큰이 변조되었는지 여부를 확인 할 수 있다.\n\n② 서버는 request가 들어오면 DB를 쿼리 하여 사용자를 검증하고 유효할 경우 사용자의 고유한 ID값을 부여하여\n\n    세션 저장소에 저장한 후, 이와 연결되는 세션 ID를 생성하여 response header에 포함시켜 반환한다.\n\n③ 사용자는 서버에서 해당 세션ID를 받아 쿠키에 저장을 한 후, 제한된 end point(인증이 필요한 요청)에 접근할 때 마다\n\n    쿠키를 request header에 포함시켜 보낸다.\n\n④ 서버에서는 쿠키를 받아 세션 저장소에서 검증한 후 요청에 해당하는 데이터를 반환한다.\n\n로그인을 마쳤다면, 이제 Token 정보를 Request Header 에 담아서 서버에 요청해보자.\n\n```mermaid\n\nsequenceDiagram\n\n    participant Client as Web Browser\n    participant Server as Authentication Server\n    participant APIServer as API Server\n    participant Database as User Database\n\n    Client ->> Client: Access Token 만료 여부 확인\n    activate Client\n\n    rect rgb(191, 255, 255)\n        opt 만료된 Access Token\n            Client ->>+ Server: Access Token 발급 요청 <br/>(+ Access Token, Refresh Token)\n            Server ->> Server: 만료 Access Token 검증\n            Server ->>+ Database: Refresh Token 검증\n            Database -->>- Server: <br/>\n            Server ->> Server: 새로운 Access Token 발급\n            Server -->>- Client: 새로운 Access Token\n        end\n    end\n\n    Client ->> APIServer: 데이터 요청 <br/> (+ Access Token)\n    activate APIServer\n    APIServer ->> APIServer: Access Token 검증\n    alt 유효한 Access Token\n        APIServer -->> Client: API 서버 로직을 실행 한 후, 요청 데이터 정상 응답\n    else 조작된 Access Token\n        APIServer -->> Client: \"권한 없음\" 응답\n    else 만료된 Access Token\n        APIServer -->> Client: \"인증 만료\" 응답\n        Note right of Client: 인증 만료인 경우, <br/>맨 위의 'Access Token 발급 요청' 실행\n    end\n    deactivate APIServer\n\n    deactivate Client\n\n```\n\n### JWT의 특징은 무엇인가?\n\n아주 오래전, 어떤 회사 신입 사원 시절에 WAS 의 Session Cluter 란 기능을 사용해 본 경험이 있다. 누군가 서버가 Session 정보를 가지고 인증하는 기능을 구현해 놓았고, 부하가 늘면서 서버를 Scale out 해야만 하는 상황이 발생하게 되었다.\n하지만, Session 정보를 가지고 있는 서버는 Stateful 했고, 당장에 이 문제를 해결하기 위해 Session Cluter 라는 방법을 택할 수 밖에 없었던 것이다.\n\n이후, 서버는 점점 더 늘어나게 되고, Session 정보를 서버간 공유하다 서비스가 다운되어, Load Balancer 를 Sticky 모드로 실행하게 되었다.\n그리고 결국, 다시 개발했던 기억이 난다.\n\n**서버는 확장성을 고려하여 반드시 Stateless 해야만 한다.** 이러한 Stateless 서버 환경에 맞는 방식이 바로 JWT 가 되겠다.\n모든 서버는 Token 을 검증할 수만 있으면 될 것이고, 심지어 인증을 담당하는 서버만 별도로 구축해 비즈니스 로직을 처리하는 API 서버와 분리할 수도 있겠다.\n\n그리고 인증을 위한 Token 을 해더 정보에 담아 전송하므로, 굳이 Cookie 에 관리하지 않아도 되겠다.\n\n쿠키에서 해방되면, CORS(Cross-Origin Resource Sharing)가 가능해지고, CSRF(Cross-Site Request Forgery) 도 어느정도? 방지할 수 있을 것이다.\n\n최근, WebView 를 포함한 하이브리드 앱을 Flutter 로 리빌드 하고 있는데, 인증 정보를 Cookie Manager를 활용하여 관리하는 일은 참으로 번거로운 일이기도 하다. 모바일 앱을 개발하는 입장에서도 Cookie Manager 에서 인증 관리를 할 필요가 없다.\n\n단점으로는 jwt 토큰이 탈취되었을 경우 누구나 해당 토큰의 권한을 가지고 서비스를 이용할 수 있습니다. 그리고 누구나 헤더와 페이로드의 내용을 볼 수 있기 때문에 보안에 위협이 될만한 정보나 개인정보가 있다면 노출될 수 있다는 단점도 있고요. (그래서 그런 정보는 넣으면 안 됩니다) 이러한 이유로 보통 jwt토큰의 만료시간(exp)을 짧게 정하고 리프래시 토큰(Refresh Token)과 함께 사용합니다.\n\n또 다른 단점으로는 토큰에 담고있는 정보가 많아질수록 데이터의 크기가 커진다는 겁니다. 그렇게 되면 네트워크 전달시 데이터의 크기로 부하가 생길 수 있습니다.\n","excerpt":"JWT 에 대해 간략하게 공유해야 할 일이 생겼다. 그래서 주요한 흐름을 아래와 같이 Sequence Diagram 으로 작성해 보았다. Sequece Diagram 은 mermaid 로 작성하였고, MDX 에 보여질 수 있도록 Getsby에 gats…","timeToRead":8.975,"tableOfContents":{"items":[{"url":"#jwt-인증-절차","title":"JWT 인증 절차","items":[{"url":"#사용자-로그인","title":"사용자 로그인","items":[{"url":"#jwt-구조","title":"JWT 구조"}]},{"url":"#jwt의-특징은-무엇인가","title":"JWT의 특징은 무엇인가?"}]}]},"banner":null}},"pageContext":{"defer":true,"id":"ea283785-b518-563c-ac1a-629269d51765","frontmatter":{"title":"토근 기반 인증 - JWT(JSON Web Token)","description":"서버는 확장성을 고려하여 반드시 Stateless 해야만 한다. 이러한 Stateless 서버 환경에 적합한 JWT 인증에 대한 Sequence Diagram 을 그려보았다.","slug":"authentication-jwt","date":"2022-10-05T00:00:00.000Z","tags":["authentication","JWT"],"defer":true}}},"staticQueryHashes":["1942088059","2744905544"]}